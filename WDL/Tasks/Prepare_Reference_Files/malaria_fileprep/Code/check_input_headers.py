import argparse
import pandas as pd
import sys
from collections import defaultdict 
import os
import subprocess 

def main():
    """
    Loads at all relevant input and intermediate files and checks that all header names match. This makes 
    the pipeline more robust to crashing from user input.   

    Usage: python Code/check_input_headers.py -i [panel_info]

    Returns:
    None.
    """

    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', help="Input path to amplicon panel_info file.", required=True)
    parser.add_argument('-rg', '--ref_genome', help="Input path for reference genome.", required=True)
    parser.add_argument('--ref_amplicons_provided', help="Boolean if reference panel was provided or auto-generated.", action='store_true')

    args = parser.parse_args()

    panel_info = args.input
    ref_genome = args.ref_genome
    ref_amplicons_provided = args.ref_amplicons_provided

    # All of these files are either user-provided OR generated by the program. Failure to have these files means there is an upstream issue.
    panel_info_bed = "amplicon_panel.bed"
    fasta_files = ["reference.fasta", "primers_fw.fasta", "primers_rv.fasta"]
    markers_table_file = "markers_table.csv"

    # Check 1 - If reference_amplicons_provided, compare it to reference that is generated from panel_info. Generate markers_table accordingly.
    if ref_amplicons_provided:
        # Reference amplicons may have different names from what could be autogenerated
        with open("reference.generated.fasta", 'w') as fd:
            subprocess.run(["bedtools", "getfasta", "-fi", ref_genome, "-bed", panel_info_bed], stdout=fd)
        # Compare autogenerated fasta to reference fasta
        ref_generated_dict, ref_generated_header_to_index = createHeaderSeqDict("reference.generated.fasta")
        ref_provided_dict, ref_provided_header_to_index = createHeaderSeqDict("reference.fasta")
        
        seqs_generated = set(ref_generated_dict.values())
        seqs_provided = set(ref_provided_dict.values())
        
        if ref_generated_dict != ref_provided_dict: 
            # Check 1.1 - The sequences must be equal.
            if (seqs_generated == seqs_provided):
                print("The sequences between panel_info + reference_genome and reference_amplicons are equal.")
            else:
                print("The sequences between the panel_info + reference_genome and the reference_amplicons must be equal.")
                print("Please provide the correct reference_genome and sequence positions in panel_info, or the correct sequences in reference_amplicons.")
                sys.exit()
            
            # Check 1.2b - If the headers are not equal, correct
            equal_headers = set(ref_generated_dict.keys()) == set(ref_provided_dict.keys())
            if equal_headers:
                print("The headers are equal.")
            else:
                print("The headers are not equal. Replacing auto-generated FASTA headers with provided headers from reference_amplicons...")
            seq_to_generated_header = {v : k for k, v in ref_generated_dict.items()}
            seq_to_provided_header = {v : k for k, v in ref_provided_dict.items()}
            generated_to_provided_headers = {seq_to_generated_header[s] : seq_to_provided_header[s] for s in seqs_generated}
            panel_info_idx_to_provided_headers = { ref_generated_header_to_index[h] : generated_to_provided_headers[h] for h in ref_generated_dict.keys()}
            markers_table = createMarkersTable(panel_info_bed, panel_info_idx_to_provided_headers)   
    else:
        # No comparison needed since reference.fasta is the auto-generated file.
        _, header_to_panel_info_index = createHeaderSeqDict("reference.fasta")
        panel_info_index_to_header = {v : k for k, v in header_to_panel_info_index.items()}
        markers_table = createMarkersTable(panel_info_bed, panel_info_index_to_header)

    # Read in fasta files
    fasta_index_dicts = defaultdict(lambda : defaultdict)
    fasta_seq_dicts = defaultdict(lambda : defaultdict)
    for fasta in fasta_files:
        fasta_base = os.path.splitext(os.path.basename(fasta))[0]
        try:
            header_to_seq_dict, header_to_index_dict = createHeaderSeqDict(fasta)
            index_to_header_dict = {v : k for k, v in header_to_index_dict.items()}
            fasta_index_dicts[fasta_base] = index_to_header_dict
            fasta_seq_dicts[fasta_base] = header_to_seq_dict
        except:
            sys.exit()
    
    # Check 2 - Check that fasta headers are similar
    # Check 2.1 - Check that reverse and forward primers have the same headers
    if set(fasta_index_dicts["primers_fw"].keys()) != set(fasta_index_dicts["primers_rv"].keys()):
        raise Exception("Forward and reverse primer files do not have the same headers. Please provide the correct headers in your primer files.")
        sys.exit()

    # Check 2.2 - Check that reference and primer files have the same headers, ignoring semicolon comments
    # primer_fw_headers_no_semicolon = {v.split(';')[0] for v in fasta_index_dicts["primers_fw"].values()}
    # primer_rv_headers_no_semicolon = {v.split(';')[0] for v in fasta_index_dicts["primers_rv"].values()}
    # if (set(fasta_index_dicts["reference"].values()) != primer_fw_headers_no_semicolon) or (set(fasta_index_dicts["reference"].values()) != primer_rv_headers_no_semicolon):
    #     raise Exception("Forward and reverse primer files do not have the same headers as the reference_amplicons file. Please provide the correct headers in your primer/reference_amplicons files.")
    #     sys.exit()
    
    print("All checks on reference files passed.")
    
    # Create markers table
    print("Generating markers table...")
    markers_table.to_csv("markers_table.csv", index=False)

def createHeaderSeqDict(fasta):
    index = 0
    index_dict = defaultdict()
    curr_fasta_dict = defaultdict(lambda : "")
    if os.path.isfile(fasta):
        headers_num_seen = defaultdict(lambda: 0) # Keep track of how many headers we have seen
        with open(fasta) as f:
            for line in f:
                line = line.strip()
                if not line: continue
                if line.startswith(">"):
                    header = line[1:]
                    headers_num_seen[header] += 1
                    index_dict[header] = index
                    index += 1
                else:
                    if headers_num_seen[header] > 1:
                        raise Exception("Non-unique FASTA header detected. Every sequence must have a unique header.")
                    else:
                        curr_fasta_dict[header] += line 
    else:
       raise Exception(f"Non-unique FASTA header in {fasta} detected. Every sequence must have a unique header.")
    return curr_fasta_dict, index_dict

def createMarkersTable(bed, index_to_names):
    amplicon_bed = pd.read_csv(filepath_or_buffer=bed, sep=None, engine="python", header=None, names=["chromosome", "start", "end"])
    amplicon_bed['amplicon'] = [index_to_names[idx] for idx in amplicon_bed.index.tolist()]
    amplicon_bed['pos'] = (amplicon_bed['start'] + amplicon_bed['end'] ) // 2
    amplicon_bed['length'] = amplicon_bed['end'] - amplicon_bed['start'] + 1
    markers_table = amplicon_bed[['amplicon', 'chromosome', 'start', 'end', 'pos', 'length']]

    return markers_table

if __name__ == "__main__":
	main()
